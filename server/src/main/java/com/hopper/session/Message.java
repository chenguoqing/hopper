package com.hopper.session;

import com.hopper.server.ComponentManagerFactory;
import com.hopper.verb.Verb;
import com.hopper.verb.VerbMappings;
import org.apache.commons.lang.builder.ToStringBuilder;

import java.io.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * {@link Message} is designed as the communication unit between endpoints.
 * {@link Message} represents the communication "header", concrete contents are
 * encapsulated into <tt>{@link #body}</tt> filed, only the implementations can
 * understand the <tt>{@link #body}</tt>.
 * <p/>
 *
 * @author chenguoqing
 */
public class Message {
    /**
     * IDGenerator
     */
    private static IDGenerator IDGen;
    /**
     * Message id
     */
    private int id;
    /**
     * Message verb
     */
    private Verb verb;
    /**
     * The associated command
     */
    private Object body;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public Verb getVerb() {
        return verb;
    }

    public void setVerb(Verb verb) {
        this.verb = verb;
    }


    public Object getBody() {
        return body;
    }

    public void setBody(Object body) {
        this.body = body;
    }

    /**
     * Calculate the next message id, message id will be generated by server id
     */
    public static int nextId() {
        if (IDGen == null) {
            synchronized (Message.class) {
                if (IDGen == null) {
                    int serverId = ComponentManagerFactory.getComponentManager().getGlobalConfiguration()
                            .getLocalServerEndpoint().serverId;

                    IDGen = new IDGenerator(serverId, serverId);
                }
            }
        }
        return IDGen.next();
    }

    /**
     * Serialize the request object to byte array. If the <tt>body</tt> is the
     * instance of {@link Serializer},invoks the
     * {@link Serializer#serialize(DataOutput)} for serializing; otherwise, if
     * <tt>body</tt> is a byte array instance, writes it directly to stream.
     */
    public byte[] serialize() {

        LengthOutputStream lengthOutputStream = new LengthOutputStream();
        DataOutputStream dos = new DataOutputStream(lengthOutputStream);

        try {
            dos.writeInt(id);
            dos.writeInt(verb.type);

            if (body instanceof Serializer) {
                ((Serializer) body).serialize(dos);
            } else if (body instanceof byte[]) {
                dos.write((byte[]) body);
            }
        } catch (IOException e) {
            // nothing
        }

        lengthOutputStream.complete();

        return lengthOutputStream.toFullByteArray();
    }

    /**
     * Deserialize the bytes to message instance. If body's class is supported,
     * using it for deserializing; otherwise, setting the byte array as the
     * body.
     */
    public void deserialize(byte[] buf) {
        ByteArrayInputStream bis = new ByteArrayInputStream(buf);
        DataInputStream in = new DataInputStream(bis);

        try {
            this.id = in.readInt();
            int iverb = in.readInt();
            this.verb = Verb.getVerb(iverb);

            if (verb == null) {
                throw new MessageDecodeException("Found the invalidate verb: " + iverb);
            }


            Class<? extends Serializer> bodyClazz = VerbMappings.getVerClass(verb);

            if (bodyClazz != null) {
                this.body = deserializeBody(in, bodyClazz);
            } else {
                int remaining = bis.available();
                if (remaining > 0) {
                    this.body = new byte[remaining];
                    bis.read((byte[]) body);
                }
            }
        } catch (Exception e) {
            throw new MessageDecodeException("Failed to deserialize the message.", e);
        }
    }

    /**
     * Deserialize the {@link DataInput} to the special instance.
     */
    private Object deserializeBody(DataInput in, Class<? extends Serializer> bodyClazz) throws Exception {
        Serializer instance = bodyClazz.newInstance();
        instance.deserialize(in);
        return instance;
    }

    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("id:").append(id).append("\r\n");
        sb.append("verb:").append(verb).append("\r\n");
        sb.append("body:").append(toBodyString(body));

        return sb.toString();
    }

    private String toBodyString(Object body) {
        if (body == null) {
            return "";
        }

        return ToStringBuilder.reflectionToString(body);
    }

    static class IDGenerator {
        final int increment;
        final AtomicInteger id;

        IDGenerator(int initial, int increment) {
            this.increment = increment;
            id = new AtomicInteger(initial);
        }

        int next() {
            return id.addAndGet(increment);
        }
    }
}
